#!/usr/bin/env python3
from typing import *
import subprocess
import argparse
import glob
import sys
import os

###############################################################################
#                                                                             #
#                                   Colors                                    #
#                                                                             #
###############################################################################

CSI     = "\033"
BOLD    = CSI + "[1;m"
DIM     = CSI + "[2;m"
BLACK   = CSI + "[30;m"
RED     = CSI + "[31;m"
GREEN   = CSI + "[32;m"
YELLOW  = CSI + "[33;m"
BLUE    = CSI + "[34;m"
MAGENTA = CSI + "[35;m"
CYAN    = CSI + "[36;m"
WHITE   = CSI + "[37;m"
DEFAULT = CSI + "[39;m"
RESET   = CSI + "[0;m"

def info(msg: str):
    print(f" {BOLD + BLUE}*{RESET} {BOLD}{msg}{RESET}", file=sys.stderr)

def warn(msg: str):
    print(f" {BOLD + YELLOW}!{RESET} {BOLD}{msg}{RESET}", file=sys.stderr)

def error(msg: str):
    print(f" {BOLD + RED}x{RESET} {BOLD}{msg}{RESET}", file=sys.stderr)


###############################################################################
#                                                                             #
#                             Variable Expansion                              #
#                                                                             #
###############################################################################

class ExpandVarNotFoundError(Exception):
    pass

class ExpandVarInvalidExpansionError(Exception):
    pass

def expand(s: str, vars: Dict[str, str]) -> str:
    out = s

    while True:
        start = out.find("{{")
        if start == -1:
            break

        var_start = start + 2

        var_end = out.find("}}", var_start)
        if var_end == -1:
            raise ExpandVarInvalidExpansionError("missing closing '}}'")

        end = var_end + 2

        var = out[var_start:var_end]
        value = vars.get(var)
        if value is None:
            raise ExpandVarNotFoundError(var)

        out = out[:start] + str(value) + out[end:]

    return out

###############################################################################

class ServiceNotFoundError(Exception):
    pass

class ServiceHookError(Exception):
    pass

class ServiceInstallSecretError(Exception):
    pass

class Service:
    name: str
    path: str

    def __init__(self, path: str):
        if not os.path.isdir(path):
            raise ServiceNotFoundError
        
        self.name = os.path.basename(path)
        self.path = path

    def _vars(self, *, env: Dict[str, str]=os.environ) -> Dict[str, str]:
        vars = {
            "root": os.path.realpath(os.path.join(self.path, "..")),
            "service": self.name,
            "service_path": self.path,
        }

        vars.update({
            f"env:{k}": v for k, v in env.items()
        })

        return vars

    def install_units(self, dst: str):
        units_path = os.path.join(self.path, "units.d")

        try:
            units = list(filter(lambda x: not os.path.isdir(x), os.listdir(units_path)))
        except FileNotFoundError:
            return

        vars = self._vars()

        for unit in units:
            src_path = os.path.join(units_path, unit)
            dst_path = os.path.join(dst, unit)

            with open(src_path, "r") as f:
                contents = '''#
# Installed by labctl. Do NOT modify!
#

''' + f.read()

            contents = expand(contents, vars)

            with open(dst_path, "w") as f:
                f.write(contents)

    def install_secrets(self):
        secrets_path = os.path.join(self.path, "secrets.d")

        try:
            secrets = filter(lambda x: not os.path.isdir(x),
                        os.listdir(secrets_path)
                    )
        except FileNotFoundError:
            return

        for secret in secrets:
            secret_path = os.path.join(secrets_path, secret)
            p = subprocess.run(["podman", "secret", "create", "--replace", secret, secret_path], stdout=subprocess.DEVNULL)
            if p.returncode != 0:
                raise ServiceInstallSecretError(secret)

    def run_hook(self, kind: str):
        hook = os.path.join(self.path, "hooks.d", kind)

        try:
            env = self._vars(env={})
            env.update(os.environ)

            p = subprocess.run([hook], cwd=self.path, env=env)
            if p.returncode != 0:
                raise ServiceHookError(p.returncode)
        except FileNotFoundError:
            pass

###############################################################################

class InstallCmd:
    @staticmethod
    def parser(parser: argparse.ArgumentParser):
        parser.add_argument("--root", default=".", metavar="path", type=os.path.realpath, help="Install as if the repo is at this path.")
        parser.add_argument("--units", default="/etc/containers/systemd", metavar="path", type=os.path.realpath, help="Install systemd units here.", dest="units_path")

    @staticmethod
    def run(args):
        service_paths = filter(os.path.isdir,
                            glob.glob(os.path.join(args.root, "*"), recursive=False)
                        )

        for path in service_paths:
            try:
                service = Service(path)
            except ServiceNotFoundError:
                continue

            service.install_units(args.units_path)

            try:
                service.install_secrets()
            except ServiceInstallSecretError as e:
                error(f"failed to install secret '{e}' for '{service.name}'")
                exit(1)

            try:
                service.run_hook("install")
            except ServiceHookError as e:
                error(f"install hook of '{service.name}' failed with code: {e}")
                exit(1)

###############################################################################

def main():
    parser = argparse.ArgumentParser("labctl")
    subparsers = parser.add_subparsers(dest="subparser", required=True)
    InstallCmd.parser(subparsers.add_parser("install"))
    args = parser.parse_args()

    run = {
        "install": InstallCmd.run,
    }

    return run[args.subparser](args)


if __name__ == "__main__":
    main()
